<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="viewport" content="initial-scale=1.0, maximum-scale=5" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <link
      rel="shortcut icon"
      href="%PUBLIC_URL%/favicon.png"
      type="image/x-icon"
    />
    <link rel="icon" href="%PUBLIC_URL%/favicon.png" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
    <meta name="apple-mobile-web-app-title" content="Blasthole_Dipping" />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <meta name="theme-color" content="#2196F3" />
    <meta name="description" content="Blast Hole Dipping App" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <title>Drill & Blast QAQC</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet.markercluster@1.3.0/dist/MarkerCluster.css"
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet.markercluster@1.3.0/dist/MarkerCluster.Default.css"
    />
    <link rel="stylesheet" href="progressbar.css" />
    <script
      src="https://kit.fontawesome.com/05c6b543c0.js"
      crossorigin="anonymous"
    ></script>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.3.0/dist/leaflet.markercluster.js"></script>
    <script
      type="text/javascript"
      src="https://cdn.jsdelivr.net/gh/hosuaby/Leaflet.SmoothMarkerBouncing@v2.0.0/dist/bundle.js"
      crossorigin="anonymous"
    ></script>
    <script src="https://code.jquery.com/jquery-1.10.2.js"></script>
    <script src="https://code.jquery.com/ui/1.11.4/jquery-ui.js"></script>
    <script src="jquery-csv.js"></script>
    <script src="progressbar.js"></script>
  </head>
  <body>
    <div id="map"></div>
    <div id="root" class="splash"></div>
    <div class="custom-popup" id="popup"></div>
    <div id="message"></div>
    <div id="worksheet"></div>
    <div id="locationbuttons">
      <img
        src="/images/btn-Locate@2x.png"
        width="50"
        height="50"
        class="mapbutton"
        title="Centre User Position"
        onclick="centerUser()"
        style="cursor: pointer"
      />
      <img
        src="/images/btn-Centre-Map@2x.png"
        width="50"
        height="50"
        class="mapbutton"
        title="Centre Site Position"
        onclick="centerSite()"
        style="cursor: pointer"
      />
    </div>
    <div id="uploadform" class="uploads">
      <label>UPLOAD DRILL PATTERN :</label><br /><br />
      <label>Ensure CSV columns:</label><br />
      <label>Hole_No,Lng,Lat,Collar,Toe,Dia,Brg,Angle</label><br /><br />
      <input
        id="pattern"
        placeholder="Input Pattern Name"
        style="width: 200px; font: normal 18px Arial"
        value=""
      /><br /><br />
      <form
        id="uploadForm"
        name="uploadForm"
        action="#"
        enctype="multipart/form-data"
      >
        <input
          id="csv"
          name="csv"
          type="file"
          style="margin-left: 0px; font: normal 16px arial"
        />
        <br />
        <br />
        <input
          id="CSVUpload"
          type="submit"
          class="btn btn-default"
          name="Submit"
          value="Upload"
        />
        <input
          type="button"
          value="Cancel"
          class="btn"
          onclick="$('#uploadform').hide()"
        />
      </form>
      <!--<img src='images/downloadcsv.png' style='cursor:pointer;width:20px;height:20px' title='Download CSV template' /><a class="fileDownloadPromise" href="templates/pattern_template.csv?n=1">Download Drill Pattern Template</a>-->
    </div>
    <div id="summary">
      <label id="summary_pattern"></label><br /><br />
      <label id="design_holes">Design Holes:</label><br />
      <label id="design_mtrs">Design Mtrs:</label><br />
      <label id="dipped_holes">Dipped Holes:</label><br />
      <label id="dipped_mtrs">Dipped Metres:</label><br />
    </div>
    <script>
      window.login = false;
      window.email;
      window.password;
      window.holedata;
      if (
        localStorage.getItem("sitelat") == null ||
        localStorage.getItem("sitelat") == undefined
      ) {
        let sitelat = 0;
        let sitelng = 0;
      }
      let sitelat = localStorage.getItem("sitelat") * 1;
      let sitelng = localStorage.getItem("sitelng") * 1;

      let dipped_holes;
      let dipped_mtrs;

      let wpid = false;
      let currentpos;
      let currentPositionMarker;
      let currentlat, currentlng;

      let currentposmarker = new L.LayerGroup();
      let holemarkers = new L.LayerGroup();
      let patternmarkers = new L.LayerGroup();
      let polygons = new L.LayerGroup();
      window.customOptions = { className: "custom-popup" };

      function getIcon(image, iconSize, iconAnchor, popupAnchor) {
        return L.icon({
          id: "",
          event_id: "",
          iconUrl: image,
          iconSize: iconSize,
          iconAnchor: iconAnchor,
          popupAnchor: popupAnchor,
        });
      }

      let holeIcon, redIcon, orangeIcon, greenIcon, blastIcon;

      map;

      function initMap() {
        map = L.map("map", { minZoom: 3, maxZoom: 23 }).setView(
          [sitelat, sitelng],
          18
        );

        map.zoomControl.setPosition("bottomright");

        map.on("zoomend", function () {
          let currentZoom = map.getZoom();
          if (map.getZoom() < 21) {
            $(".leaflet-tooltip-own").css("display", "none");
          } else {
            $(".leaflet-tooltip-own").css("display", "block");
          }
          if (map.getZoom() > 16 && map.getZoom() < 21) {
            $(".patternmarkers").css("display", "block");
          } else {
            $(".patternmarkers").css("display", "none");
          }
        });

        holeIcon = L.Icon.extend({
          iconUrl: "%PUBLIC_URL%/images/bh_white.png?n=1",
          iconSize: [10, 10],
          iconAnchor: [5, 5],
        });

        redIcon = L.Icon.extend({
          iconUrl: "%PUBLIC_URL%/images/bh_red.png?n=1",
          iconSize: [10, 10],
          iconAnchor: [5, 5],
        });
        orangeIcon = L.Icon.extend({
          iconUrl: "%PUBLIC_URL%/images/bh_orange.png?n=1",
          iconSize: [10, 10],
          iconAnchor: [5, 5],
        });
        greenIcon = L.Icon.extend({
          iconUrl: "%PUBLIC_URL%/images/bh_green.png?n=1",
          iconSize: [10, 10],
          iconAnchor: [5, 5],
        });
        blastIcon = L.Icon.extend({
          iconUrl: "%PUBLIC_URL%/images/bh_blue.png?n=1",
          iconSize: [2, 2],
          iconAnchor: [1, 1],
        });

        if (window.login == true) {
          openDb();
        }
      }

      function displayAndWatch(position) {
        setCurrentPosition(position);
      }

      function locError(error) {
        switch (error.code) {
          case error.PERMISSION_DENIED:
            //showMessage("location services permission denied");
            break;
          case error.POSITION_UNAVAILABLE:
            //showMessage("gps position unavailable");
            wpid = navigator.geolocation.getCurrentPosition(
              displayAndWatch,
              locError,
              { maximumAge: 0, timeout: 1000, enableHighAccuracy: true }
            );
            break;
          case error.TIMEOUT:
            //showMessage("gps timeout");
            wpid = navigator.geolocation.getCurrentPosition(
              displayAndWatch,
              locError,
              { maximumAge: 0, timeout: 1000, enableHighAccuracy: true }
            );
            break;
          case error.UNKNOWN_ERROR:
            //showMessage("unknown gps error");
            wpid = navigator.geolocation.getCurrentPosition(
              displayAndWatch,
              locError,
              { maximumAge: 0, timeout: 1000, enableHighAccuracy: true }
            );
            break;
        }
      }

      function setCurrentPosition(pos) {
        currentlat = pos.coords.latitude;
        currentlng = pos.coords.longitude;
        currentposmarker.clearLayers();
        currentPositionMarker = L.marker(
          [pos.coords.latitude, pos.coords.longitude],
          {
            icon: L.icon({
              iconUrl: "%PUBLIC_URL%/images/pos.png",
              iconSize: [2, 2],
              iconAnchor: [1, 1],
            }),
            tap: false,
          }
        ).addTo(map);
        currentposmarker.addLayer(currentPositionMarker);
      }

      //get user location every 5 seconds
      setInterval(function () {
        if (!!navigator.geolocation) {
          wpid = navigator.geolocation.getCurrentPosition(
            displayAndWatch,
            locError,
            {
              maximumAge: 0,
              timeout: 1000,
              enableHighAccuracy: true,
            }
          );
        }
      }, 5000);

      function centerUser() {
        map.setView(new L.LatLng(currentlat, currentlng), 18);
      }

      function centerSite() {
        map.setView(new L.LatLng(sitelat, sitelng), 18);
      }

      //when dom body ready, initiate the map and geolocation
      $(document).ready(function () {
        initMap();
        if (!!navigator.geolocation) {
          wpid = navigator.geolocation.getCurrentPosition(
            displayAndWatch,
            locError,
            {
              maximumAge: 0,
              timeout: 1000,
              enableHighAccuracy: true,
            }
          );
        } else {
          showMessage("Your browser does not support the Geolocation API");
        }
        $("#summary_pattern").html(localStorage.getItem("pattern"));
        if (localStorage.getItem("bh_database") === "false") {
          $("#uploadcsv").hide();
        }
      });

      //alert message function
      function showMessage(message) {
        $("#message").html(message).css({ display: "table-cell" }).show();
        setTimeout(function () {
          $("#message").html("").hide();
        }, 3000);
      }

      var geojson = [];

      //get all indexedDB stored polygons

      function getPolygons() {
        if ((window.login = true)) {
          var store = window.db
            .transaction("polygons", "readwrite")
            .objectStore("polygons");
          var req;
          try {
            req = store.getAll();
          } catch (e) {
            console.log(e);
          }
          req.onsuccess = function (evt) {
            delete req.result[0]["id"];
            geojson = req.result[0];
            L.geoJson(geojson, {
              style: areaStyle,
              onEachFeature: onEachFeature,
            }).addTo(map);
            var bounds = L.latLngBounds();
            for (var j = 0; j < geojson.features.length; j++) {
              if (geojson.features[j].geometry.type === "Polygon") {
                var coords = geojson.features[j].geometry.coordinates[0];
                for (var i = 0; i < coords.length; i++) {
                  if (coords[i][1] !== undefined || coords[i][1] !== 0) {
                    bounds.extend(L.latLng(coords[i][1], coords[i][0]));
                  }
                }
              }
              var marker = L.marker(
                [
                  geojson.features[j].properties.lat,
                  geojson.features[j].properties.lng,
                ],
                {
                  icon: L.icon({
                    iconUrl: "%PUBLIC_URL%/images/bh_blue.png?n=1",
                    iconSize: [2, 2],
                    iconAnchor: [1, 1],
                  }),
                  tap: false,
                }
              ).addTo(map);
              marker.bindTooltip(geojson.features[j].properties.Block, {
                permanent: true,
                direction: "right",
                offset: [0, 0],
                className: "patternmarkers",
              });
              patternmarkers.addLayer(marker);
            }
            map.fitBounds(bounds);
            map.panTo(bounds.getCenter());
          };
          req.onerror = function () {
            console.error("read db error", this.error);
          };
        }
      }

      //polygon event listener
      function onEachFeature(feature, layer) {
        layer.on({
          click: onClick,
        });
      }

      //styling the polygon
      function areaStyle(feature) {
        return {
          strokeColor: feature.properties.strokeColor,
          fillColor: feature.properties.fillColor,
          fillOpacity: 0,
          weight: 1,
          opacity: 1,
        };
      }

      //polygon event listener
      function onClick(e) {
        getPattern(e.target.feature.properties.Block);
        $("#summary_pattern").html(e.target.feature.properties.Block);
      }

      //Hole event listener

      function onHoleClick(id) {
        getHole(id);
      }

      //Styling the polygons
      function patternStyle(feature) {
        return {
          i: feature.properties.fillColor,
          fillColor: feature.properties.fillColor,
          fillOpacity: 0,
          weight: 1,
          opacity: 1,
        };
      }

      //indexedDB functions
      window.db;
      window.DB_NAME = "blasts";
      window.DB_VERSION = 5;
      window.DB_STORE_NAME = "patterns";

      //open indexedDB
      function openDb() {
        var req = indexedDB.open(window.DB_NAME, window.DB_VERSION);
        req.onsuccess = function (evt) {
          window.db = this.result;
          console.log(window.db);
          getPolygons();
          if (
            localStorage.getItem("pattern") === null ||
            localStorage.getItem("pattern") === undefined
          ) {
          } else {
            getPattern(localStorage.getItem("pattern")); //automatically get last accessed pattern
          }
        };
        req.onerror = function (evt) {
          console.error("openDb:", evt.target.errorCode);
        };

        req.onupgradeneeded = function (evt) {
          //var req = indexedDB.deleteDatabase("blasts");

          //evt.currentTarget.result.deleteObjectStore("polygons");
          //evt.currentTarget.result.deleteObjectStore("patterns");
          //evt.currentTarget.result.deleteObjectStore("offlineholes");
          var polygonstore = evt.currentTarget.result.createObjectStore(
            "polygons",
            {
              keyPath: "id",
              autoIncrement: true,
            }
          );

          var store = evt.currentTarget.result.createObjectStore(
            window.DB_STORE_NAME,
            {
              keyPath: "id",
              autoIncrement: true,
            }
          );
          store.createIndex("id", "id", { unique: true });
          store.createIndex("blast", "blast", { unique: false });
          store.createIndex("hole", "hole", { unique: false });
          store.createIndex("holetype", "holetype", { unique: false });
          store.createIndex("collar", "collar", { unique: false });
          store.createIndex("toe", "toe", { unique: false });
          store.createIndex("angle", "angle", { unique: false });
          store.createIndex("dipped", "dipped", { unique: false });
          store.createIndex("lat", "lat", { unique: false });
          store.createIndex("lng", "lng", { unique: false });

          var offlinestore = evt.currentTarget.result.createObjectStore(
            "offlineholes",
            {
              keyPath: "id",
              autoIncrement: true,
            }
          );
          offlinestore.createIndex("id", "id", { unique: true });
          offlinestore.createIndex("blast", "blast", { unique: false });
          offlinestore.createIndex("hole", "hole", { unique: false });
          offlinestore.createIndex("holetype", "holetype", { unique: false });
          offlinestore.createIndex("collar", "collar", { unique: false });
          offlinestore.createIndex("toe", "toe", { unique: false });
          offlinestore.createIndex("angle", "angle", { unique: false });
          offlinestore.createIndex("dipped", "dipped", { unique: false });
          offlinestore.createIndex("lat", "lat", { unique: false });
          offlinestore.createIndex("lng", "lng", { unique: false });
        };
      }

      //add hole data to the IndexedDB store 'patterns'
      function addHole(
        blast,
        hole,
        holetype,
        collar,
        toe,
        angle,
        dipped,
        lat,
        lng
      ) {
        var obj = {
          blast: blast,
          hole: hole,
          holetype: holetype,
          collar: collar,
          toe: toe,
          angle: angle,
          dipped: dipped,
          lat: lat,
          lng: lng,
        };
        var store = window.db
          .transaction(window.DB_STORE_NAME, "readwrite")
          .objectStore(window.DB_STORE_NAME);
        var req;
        try {
          req = store.add(obj);
        } catch (e) {
          if (e.name == "DataCloneError")
            console.log(
              "This engine doesn't know how to clone a Blob, use Firefox"
            );
          throw e;
        }
        req.onsuccess = function (evt) {};
        req.onerror = function () {
          console.error("addHole error", this.error);
        };
      }

      pbounds = L.latLngBounds();

      //get selected or localStorage pattern

      function getPattern(pattern) {
        if (pattern !== null || pattern !== undefined) {
          holemarkers.clearLayers();
          var store = window.db
            .transaction(window.DB_STORE_NAME, "readwrite")
            .objectStore(window.DB_STORE_NAME);
          var req;
          try {
            var myIndex = store.index("blast");
            var getRequest = myIndex.get(pattern);
          } catch (e) {
            if (e.name == "DataCloneError")
              console.log(
                "This engine doesn't know how to clone a Blob, use Firefox"
              );
            throw e;
          }
          getRequest.onsuccess = function () {
            console.log(getRequest.result);
            localStorage.setItem("pattern", pattern);
            design_holes = 0;
            design_mtrs = 0;
            dipped_holes = 0;
            dipped_mtrs = 0;
          };

          myIndex.openCursor(pattern).onsuccess = function (event) {
            let cursor = event.target.result;

            if (cursor) {
              pbounds.extend(L.latLng(cursor.value.lat, cursor.value.lng));
              design_holes += 1;
              var depth = (cursor.value.collar - cursor.value.toe).toFixed(1);
              design_mtrs += depth * 1;
              var difference = cursor.value.dipped - depth;
              if (cursor.value.dipped * 1 === 0) {
                var icon = L.icon({
                  iconUrl: "%PUBLIC_URL%/images/bh_white.png?n=1",
                  iconSize: [10, 10],
                  iconAnchor: [5, 5],
                });
              } else {
                dipped_holes += 1;
                dipped_mtrs += cursor.value.dipped * 1;
                if (difference > -0.3 && difference < 0.3) {
                  var icon = L.icon({
                    iconUrl: "%PUBLIC_URL%/images/bh_green.png?n=1",
                    iconSize: [10, 10],
                    iconAnchor: [5, 5],
                  });
                } else {
                  if (difference > -0.5 && difference < 0.5) {
                    var icon = L.icon({
                      iconUrl: "%PUBLIC_URL%/images/bh_orange.png?n=1",
                      iconSize: [10, 10],
                      iconAnchor: [5, 5],
                    });
                  } else {
                    var icon = L.icon({
                      iconUrl: "%PUBLIC_URL%/images/bh_red.png?n=1",
                      iconSize: [10, 10],
                      iconAnchor: [5, 5],
                    });
                  }
                }
              }
              var html =
                "<div>" +
                "<label>Pattern: " +
                cursor.value.blast +
                "</label><br/>" +
                "<label>Hole: " +
                cursor.value.hole +
                "</label><br/>" +
                "<label>Type: " +
                cursor.value.holetype +
                "</label><br/>" +
                "<label>Depth: " +
                depth +
                "</label><br/>" +
                "<label>Dipped:</label><input id='dippedval' autocomplete='off' style='margin-left:10px;width:100px' value=''><br/><br/><input type='button' value='OK' style='width:200px' onclick=\"setHole()\"/><br/><br/><input type='button' value='Cancel' style='width:200px' onclick=\"map.closePopup()\"/>";

              var marker = L.marker([cursor.value.lat, cursor.value.lng], {
                icon: icon,
                id: cursor.value.id,
                hole: cursor.value.hole,
                type: cursor.value.holetype,
                collar: cursor.value.collar,
                toe: cursor.value.toe,
                dipped: cursor.value.dipped,
                tap: false,
              }).addTo(map);

              marker.myID = cursor.value.id;
              marker
                .on("click", function (event) {
                  onHoleClick(event.target.myID);
                })
                .bindTooltip(cursor.value.hole, {
                  permanent: true,
                  direction: "right",
                  offset: [10, 0],
                  className: "leaflet-tooltip-own",
                })
                .bindPopup(html, window.customOptions);
              holemarkers.addLayer(marker);

              cursor.continue();
            } else {
              showMessage(pattern + " Loaded");
            }
            map.fitBounds(pbounds);
            map.panTo(pbounds.getCenter());
            $("#design_holes").html("Design Holes: " + design_holes);
            $("#design_mtrs").html("Design Mtrs: " + design_mtrs.toFixed(1));
            $("#dipped_holes").html("Dipped Holes: " + dipped_holes);
            $("#dipped_mtrs").html("Dipped Metres: " + dipped_mtrs.toFixed(1));
            $("#summary").show();
            holemarkers.eachLayer(function (layer) {
              var depth = layer.options.Collar * 1 - layer.options.Toe * 1;
              var difference = layer.options.dipped * 1 - depth;
            });
          };
        }
      }

      window.holeObj;
      window.alreadydipped;
      window.alreadydippedmtrs;

      //get hole from IndexedDB pattern store
      function getHole(id) {
        window.alreadydipped = 0;
        window.alreadydippedmtrs = 0;
        var store = window.db
          .transaction(window.DB_STORE_NAME, "readwrite")
          .objectStore(window.DB_STORE_NAME);
        var req;
        try {
          req = store.get(id);
        } catch (e) {
          if (e.name == "DataCloneError")
            console.log(
              "This engine doesn't know how to clone a Blob, use Firefox"
            );
          throw e;
        }
        req.onsuccess = function (evt) {
          window.holeObj = req.result;
          if (window.holeObj.dipped > 0) {
            alreadydipped = 1;
            alreadydippedmtrs = window.holeObj.dipped;
          }
          var depth = req.result.collar * 1 - req.result.toe * 1;
          $("#dippedval").val(window.holeObj.dipped);
        };
        req.onerror = function () {
          console.error("read db error", this.error);
        };
      }

      //save hole depth to pattern store and redraw hole icon
      function setHole() {
        var dipped = $("#dippedval").val() * 1;
        if ((alreadydipped = 1)) {
          dipped_holes = dipped_holes - 1;
          dipped_mtrs = dipped_mtrs - window.alreadydippedmtrs;
        }
        dipped_holes += 1;
        dipped_mtrs += dipped;
        $("#dipped_holes").html("Dipped Holes: " + dipped_holes);
        $("#dipped_mtrs").html("Dipped Metres: " + dipped_mtrs.toFixed(1));
        window.holeObj.dipped = dipped;
        var depth = window.holeObj.collar * 1 - window.holeObj.toe * 1;
        depth = depth.toFixed(1);
        var difference = dipped - depth;

        holemarkers.eachLayer(function (layer) {
          if (layer.options.hole === window.holeObj.hole) {
            holemarkers.removeLayer(layer);
          }
        });

        if (dipped === 0) {
          var icon = L.icon({
            iconUrl: "%PUBLIC_URL%/images/bh_white.png?n=1",
            iconSize: [10, 10],
            iconAnchor: [5, 5],
          });
        } else {
          if (difference > -0.3 && difference < 0.3) {
            var icon = L.icon({
              iconUrl: "%PUBLIC_URL%/images/bh_green.png?n=1",
              iconSize: [10, 10],
              iconAnchor: [5, 5],
            });
          } else {
            if (difference > -0.5 && difference < 0.5) {
              var icon = L.icon({
                iconUrl: "%PUBLIC_URL%/images/bh_orange.png?n=1",
                iconSize: [10, 10],
                iconAnchor: [5, 5],
              });
            } else {
              var icon = L.icon({
                iconUrl: "%PUBLIC_URL%/images/bh_red.png?n=1",
                iconSize: [10, 10],
                iconAnchor: [5, 5],
              });
            }
          }
        }
        var html =
          "<div>" +
          "<label>Pattern: " +
          window.holeObj.blast +
          "</label><br/>" +
          "<label>Hole: " +
          window.holeObj.hole +
          "</label><br/>" +
          "<label>Type: " +
          window.holeObj.holetype +
          "</label><br/>" +
          "<label>Depth: " +
          depth +
          "</label><br/>" +
          "<label>Dipped:</label><input id='dippedval' autocomplete='off' style='margin-left:10px;width:100px' value=''><br/><br/><input type='button' value='OK' style='width:200px' onclick=\"setHole()\"/><br/><br/><input type='button' value='Cancel' style='width:200px' onclick=\"map.closePopup()\"/>";
        var marker = L.marker([window.holeObj.lat, window.holeObj.lng], {
          icon: icon,
          id: window.holeObj.id,
          hole: window.holeObj.hole,
          type: window.holeObj.holetype,
          collar: window.holeObj.collar,
          toe: window.holeObj.toe,
          dipped: window.holeObj.dipped,
          tap: false,
        }).addTo(map);
        marker.myID = window.holeObj.id;
        marker
          .on("click", function (event) {
            onHoleClick(event.target.myID);
          })
          .bindPopup(html, window.customOptions);
        holemarkers.addLayer(marker);
        window.alreadydipped = 0;
        window.alreadydippedmtrs = 0;
        var store = window.db
          .transaction(window.DB_STORE_NAME, "readwrite")
          .objectStore(window.DB_STORE_NAME);
        var req;
        try {
          req = store.put(window.holeObj);
        } catch (e) {
          if (e.name == "DataCloneError")
            console.log(
              "This engine doesn't know how to clone a Blob, use Firefox"
            );
          throw e;
        }
        req.onsuccess = function (evt) {
          //map.closePopup();
          uploadHole(window.holeObj);
        };
        req.onerror = function () {
          console.error("read db error", this.error);
        };
      }

      //upload hole data to HaulSmart database if internet connected else push to offline holes store
      function uploadHole() {
        if (localStorage.getItem("bh_database") == "true") {
          if (navigator.onLine === true) {
            $.ajax({
              url: "https://www.haulsmart.com/apis/setHole.php",
              type: "POST",
              data: { json: JSON.stringify(window.holeObj) },
              timeout: 10000,
              error: function () {
                storeOfflineHole(window.holeObj, "UPLOAD ERROR: ");
              },
              dataType: "text",
              success: function (text) {
                showMessage("Hole updated on HaulSmart");
                //map.closePopup();
                storeOfflineHole(window.holeObj, "TEST: ");
              },
            });
          } else {
            storeOfflineHole(window.holeObj, "NO INTERNET: ");
          }
        }
      }

      setInterval(function () {
        uploadOfflineHoles();
      }, 60000);

      function storeOfflineHole(data, error) {
        var store = window.db
          .transaction("offlineholes", "readwrite")
          .objectStore("offlineholes");
        var req;
        try {
          req = store.put(data);
        } catch (e) {
          if (e.name == "DataCloneError")
            console.log(
              "This engine doesn't know how to clone a Blob, use Firefox"
            );
          throw e;
        }
        req.onsuccess = function (evt) {
          showMessage(error + "Hole stored on device");
          //map.closePopup();
        };
        req.onerror = function () {
          console.error("read db error", this.error);
        };
      }

      function uploadOfflineHoles() {
        if (localStorage.getItem("bh_database") == "true") {
          if (navigator.onLine === true) {
            var store = window.db
              .transaction("offlineholes", "readwrite")
              .objectStore("offlineholes");
            var req;
            try {
              req = store.getAll();
            } catch (e) {
              if (e.name == "DataCloneError")
                console.log(
                  "This engine doesn't know how to clone a Blob, use Firefox"
                );
              throw e;
            }
            req.onsuccess = function (evt) {
              if (req.result.length > 0) {
                $.ajax({
                  url: "https://www.haulsmart.com/apis/setHoles.php",
                  type: "POST",
                  data: { json: JSON.stringify(req.result) },
                  timeout: 10000,
                  error: function () {
                    storeOfflineHole(window.holeObj, "UPLOAD ERROR: ");
                  },
                  dataType: "text",
                  success: function (text) {
                    showMessage("Cloud Data insync");
                    let clearstore = window.db
                      .transaction("offlineholes", "readwrite")
                      .objectStore("offlineholes")
                      .clear();
                  },
                });
              }
            };
            req.onerror = function () {
              console.error("read db error", this.error);
            };
          }
        }
      }

      if ("serviceWorker" in navigator) {
        window.addEventListener("load", function () {
          navigator.serviceWorker.register("/service-worker.js").then(
            function (registration) {
              console.log(
                "ServiceWorker registration successful with scope: ",
                registration.scope
              );
            },
            function (err) {
              console.log("ServiceWorker registration failed: ", err);
            }
          );
        });
      }

      function holesort() {
        window.holedata.sort(function (a, b) {
          var textA = a.hole.toUpperCase();
          var textB = b.hole.toUpperCase();
          return textA < textB ? -1 : textA > textB ? 1 : 0;
        });
        sortWorksheet();
      }

      function gpssort() {
        for (var i = 0; i < window.holedata.length; i++) {
          var distance = getDistance(
            [currentlat, currentlng],
            [window.holedata[i].lat, window.holedata[i].lng]
          );
          window.holedata[i].distance = distance;
        }
        window.holedata.sort(function (a, b) {
          return parseFloat(a.distance) - parseFloat(b.distance);
        });
        sortWorksheet();
      }

      //sorting the worksheet by either gps or alphabetically
      function sortWorksheet() {
        var html =
          "<img src='images/btn-close@2x.png' style='cursor:pointer;margin-left:5px;width:50px;height:50px;' onclick=\"$('#worksheet').hide();$('#lpanel').hide();$('#panelout').show();$('#panelin').hide()\" ><label style='margin-left:20px;font:bold 30px Arial'><?php echo $id;?></label><div style='text-align:left;font:Bold 30px Arial'></div><br/>";
        html +=
          "<input type='button' value='Hole Sort' class='btn' style='margin-left:10px;width:150px;font:normal 20px Arial' onclick=\"holesort()\" /><input type='button' value='GPS Sort' class='btn' style='margin-left:10px;width:150px;font:normal 20px Arial' onclick=\"gpssort()\" /><br/><div><table id='diptable' style='margin-left:10px;text-align:center;font:normal 20px Arial'><br/>";
        html +=
          "<tr><th style='width:70px' >Hole No</th><th style='width:70px'>Design Depth</th><th style='width:70px'>Redrills</th><th style='width:70px'>Dipped Depth</th><th style='width:70px'>Water</th><th style='width:70px'>Backfill</th><th style='width:70px'>Stemmed</th><th style='width:70px'>Comments</th><tr/>";
        for (var i = 0; i < window.holedata.length; i++) {
          var depth = (
            window.holedata[i].collar - window.holedata[i].toe
          ).toFixed(1);
          var difference = window.holedata[i].dipped - depth;
          if (window.holedata[i].dipped * 1 === 0) {
            var bgcolor = "white";
          } else {
            if (difference > -0.3 && difference < 0.3) {
              var bgcolor = "green";
            } else {
              if (difference > -0.5 && difference < 0.5) {
                var bgcolor = "orange";
              } else {
                var bgcolor = "red";
              }
            }
          }
          html +=
            "<tr><td><input type='text' id='hid" +
            window.holedata[i].id +
            "' readonly  class='save' readonly style='width:70px;font:normal 20px Arial' value='" +
            window.holedata[i].hole +
            "'/></td><td><input type='number' id='ded" +
            window.holedata[i].id +
            "' class='save' readonly style='width:70px;font:normal 20px Arial' value='" +
            depth +
            "'/></td><td><input type='number' id='red" +
            window.holedata[i].id +
            "' class='save' style='width:70px;font:normal 20px Arial' value=''/></td><td><input type='number' id='did" +
            window.holedata[i].id +
            "' class='save' style='width:70px;font:normal 20px Arial;background-color:" +
            bgcolor +
            "' value='" +
            window.holedata[i].dipped +
            "'/></td><td><input type='number' id='wat" +
            window.holedata[i].id +
            "' class='save' style='width:70px;font:normal 20px Arial' value=''/></td><td><input type='number' id='baf" +
            window.holedata[i].id +
            "' class='save' style='width:70px;font:normal 20px Arial' value=''/></td><td><input type='number' id='stm" +
            window.holedata[i].id +
            "' class='save' style='width:70px;font:normal 20px Arial' value=''/></td><td><textarea id='com" +
            window.holedata[i].id +
            "' class='save' style='width:300px;height:25px;font:normal 20px Arial' ></textarea></td><tr/>";
        }

        html += "</table></div>";
        $("#worksheet").html(html).show();

        $(".save").bind("change", function () {
          let str = $(this).attr("id");
          let hid = str.substr(3);
          hid = hid * 1;
          let hdipped = $(this).attr("dipped") * 1;
          let store = window.db
            .transaction(window.DB_STORE_NAME, "readwrite")
            .objectStore(window.DB_STORE_NAME);
          let req;
          try {
            req = store.get(hid);
          } catch (e) {
            if (e.name == "DataCloneError")
              console.log(
                "This engine doesn't know how to clone a Blob, use Firefox"
              );
            throw e;
          }
          req.onsuccess = function (evt) {
            window.holeObj = req.result;
            $("#dippedval").val(window.holeObj.dipped);
            let dipped = $("#did" + hid).val() * 1;
            window.holeObj.dipped = dipped;
            let depth = window.holeObj.collar * 1 - window.holeObj.toe * 1;
            depth = depth.toFixed(1);
            let difference = dipped - depth;
            if (hdipped > 0) {
              window.dipped_holes = window.dipped_holes - 1;
              window.dipped_mtrs - window.dipped_mtrs - hdipped;
            }
            window.dipped_holes += 1;
            window.dipped_mtrs += dipped;
            $("#dipped_holes").html("Dipped Holes: " + window.dipped_holes);
            $("#dipped_mtrs").html(
              "Dipped Metres: " + window.dipped_mtrs.toFixed(1)
            );
            $(this).attr("dipped", dipped);
            try {
              req = store.put(window.holeObj);
            } catch (e) {
              if (e.name == "DataCloneError")
                console.log(
                  "This engine doesn't know how to clone a Blob, use Firefox"
                );
              throw e;
            }
            req.onsuccess = function (evt) {
              //uploadHole(window.holeObj);
            };
            req.onerror = function () {
              console.error("read db error", this.error);
            };
          };
          req.onerror = function () {
            console.error("read db error", this.error);
          };
        });
      }

      //calculating distance between user position and hole position to sort worksheet closest to furthest hole

      function getDistance(origin, destination) {
        // return distance in meters
        var lon1 = toRadian(origin[1]),
          lat1 = toRadian(origin[0]),
          lon2 = toRadian(destination[1]),
          lat2 = toRadian(destination[0]);

        var deltaLat = lat2 - lat1;
        var deltaLon = lon2 - lon1;

        var a =
          Math.pow(Math.sin(deltaLat / 2), 2) +
          Math.cos(lat1) * Math.cos(lat2) * Math.pow(Math.sin(deltaLon / 2), 2);
        var c = 2 * Math.asin(Math.sqrt(a));
        var EARTH_RADIUS = 6371;
        return c * EARTH_RADIUS * 1000;
      }

      //convert to Radians
      function toRadian(degree) {
        return (degree * Math.PI) / 180;
      }

      //upload csv pattern file for storing in indexedDB
      $("#uploadForm").submit(function (event) {
        event.preventDefault();
        event.stopPropagation();
        var file = document.getElementById("csv").files[0];
        var filename = document.getElementById("csv").value;
        var path = filename.slice(0, 12);
        var ext = filename.substr(filename.lastIndexOf(".") + 1);
        if (ext === "csv") {
          var reader = new FileReader();
          reader.readAsText(file);
          reader.onload = function (e) {
            var header = "Hole,Lng,Lat,Collar,Toe,Dia,Brg,Angle";
            var csvString = header + "\n" + e.target.result;
            var data = JSON.stringify($.csv.toObjects(csvString));

            let pattern = $("#pattern").val();
            var url =
              "https://www.haulsmart.com/apis/drillcsvjson.php?id=" +
              pattern +
              "&username=" +
              localStorage.getItem("email") +
              "&password=" +
              localStorage.getItem("password") +
              "&lat=" +
              currentlat +
              "&lng=" +
              currentlng;
            $.ajax({
              url: url,
              type: "POST",
              dataType: "json",
              crossDomain: true,
              data: { json: data },
              success: function (data) {
                localStorage.setItem("pattern", pattern);

                holemarkers.clearLayers();
                var bounds = L.latLngBounds();
                let geojson = data[0];
                L.geoJson(data[1], {
                  style: areaStyle,
                  onEachFeature: onEachFeature,
                }).addTo(map);
                for (var j = 0; j < geojson.features.length; j++) {
                  var coords = geojson.features[j].geometry.coordinates;
                  bounds.extend([coords[1], coords[0]]);
                  var depth = (
                    geojson.features[j].properties.Collar -
                    geojson.features[j].properties.Toe
                  ).toFixed(1);
                  var html =
                    "<div>" +
                    "<label>Pattern: " +
                    geojson.features[j].properties.Blast +
                    "</label><br/>" +
                    "<label>Hole: " +
                    geojson.features[j].properties.Hole +
                    "</label><br/>" +
                    "<label>Type: " +
                    geojson.features[j].properties.HoleType +
                    "</label><br/>" +
                    "<label>Depth: " +
                    depth +
                    "</label><br/>" +
                    "<label>Dipped:</label><input id='dippedval' autocomplete='off' style='margin-left:10px;width:100px' value=''><br/><br/><input type='button' value='OK' style='width:200px' onclick=\"setHole()\"/><br/><br/><input type='button' value='Cancel' style='width:200px' onclick=\"map.closePopup()\"/>";
                  var marker = L.marker([coords[1], coords[0]], {
                    icon: L.icon({
                      iconUrl: "%PUBLIC_URL%/images/bh_white.png?n=1",
                      iconSize: [10, 10],
                      iconAnchor: [5, 5],
                    }),
                    id: geojson.features[j].properties.Hole,
                    type: geojson.features[j].properties.HoleType,
                    collar: geojson.features[j].properties.Collar,
                    toe: geojson.features[j].properties.Toe,
                    dia: geojson.features[j].properties.Dia,
                    tap: false,
                  }).addTo(map);
                  marker.myID = j;
                  marker
                    .on("click", function (event) {
                      onHoleClick(event.target.myID);
                    })
                    .bindPopup(html);
                  holemarkers.addLayer(marker);
                  addHole(
                    geojson.features[j].properties.Blast,
                    geojson.features[j].properties.Hole,
                    geojson.features[j].properties.HoleType,
                    geojson.features[j].properties.Collar,
                    geojson.features[j].properties.Toe,
                    geojson.features[j].properties.Angle,
                    geojson.features[j].properties.Dipped,
                    coords[1],
                    coords[0]
                  );
                }
                map.fitBounds(bounds);
                map.panTo(bounds.getCenter());
                $("#uploadform").hide();
              },
            });
          };
        } else {
          showMessage("Please ensure you upload a csv file");
        }
      });
    </script>
  </body>
</html>
